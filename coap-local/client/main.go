package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"go.opentelemetry.io/otel"
)

// Config holds all configuration settings for the system
type Config struct {
	LogAddr          string        // CoAP server address for logs
	MetricAddr       string        // CoAP server address for metrics
	DeviceIDs        []string     
	BatchSize        int           // Number of log entries to send per batch
	BatchInterval    time.Duration // Time interval between batch sends
	MetricInterval   time.Duration // Time interval between sending metrics
	EventGenInterval EventIntervalConfig // Configuration for event generation intervals
}

// EventIntervalConfig defines minimum and maximum durations for random event generation
type EventIntervalConfig struct {
    Min time.Duration
    Max time.Duration
}

// loadConfig loads the system configuration with default values
func loadConfig() Config {
	cfg := Config{
		LogAddr:        "localhost:5683",  // Default CoAP port
		MetricAddr:     "localhost:5683",  // Same server, different resource path
		BatchSize:      30,
		BatchInterval:  1 * time.Minute,
		MetricInterval: 60 * time.Second,
		DeviceIDs: []string{
			"Device-001", "Device-002",
		},
	}
	
	cfg.EventGenInterval.Min = 10 * time.Second
	cfg.EventGenInterval.Max = 15 * time.Second

	log.Printf("Configurazione caricata: %d dispositivi, batch size: %d", 
		len(cfg.DeviceIDs), cfg.BatchSize)
	
	return cfg
}


// This function receives a cancelFunc parameter, which is a cancel function generated by context.WithCancel().
// It is used to notify other goroutines that "it's time to exit."
func handleShutdown(cancelFunc context.CancelFunc) {
	// This is a channel used to receive system signals.
	signalChan := make(chan os.Signal, 1)
	// register the types of signals to listen for.
	signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM, syscall.SIGINT)

	// Attende un segnale
	sig := <-signalChan // Block until a signal is received.

	log.Println("Interrupt signal received, shutting down...",sig)
	// This triggers the ctx.Done() channel created by context.WithCancel() to be closed.
	cancelFunc()
}

func main() {
	log.Println("Starting IoT device simulation system with CoAP...")

	// Start root context with cancel function
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Start a goroutine to handle shutdown signals (e.g., Ctrl+C)
	go handleShutdown(cancel)

	// Load configuration settings
	cfg := loadConfig()

	// Setup OpenTelemetry tracer
	shutdown, err := setupTracer()
	if err != nil {
		log.Fatalf("Tracer error: %v", err)
	}
	defer shutdown(ctx)

	// Create a tracer instance to be used by CoAP clients and senders
	tracer := otel.Tracer("device-simulator")

	logSenders := make([]*LogSender, 0, len(cfg.DeviceIDs))
	metricSenders := make([]*MetricSender, 0, len(cfg.DeviceIDs))

	// For each device ID in configuration
	for _, deviceID := range cfg.DeviceIDs {
		// Create a log sender dedicated for this device
		logSender := NewLogSender(deviceID, cfg.LogAddr, "/batchLog", tracer)
		logSenders = append(logSenders, logSender)

		// Initialize metric sender for this device
		metricSender := NewMetricSender(deviceID, cfg.MetricAddr, "/batchMetric", tracer)
		metricSenders = append(metricSenders, metricSender)
		log.Printf("Started device: %s", deviceID)
	}

	// Casual events/logs to simulate a devices internal operation
	go runEventGenerators(ctx, logSenders, cfg.EventGenInterval)

	// Start a goroutine to send logs periodically for all logSenders
	go runLogSenders(ctx, logSenders, cfg.BatchInterval, cfg.BatchSize)

	// Start a goroutine to send metrics periodically (every 1 minute 30 seconds)
	go runMetricSenders(ctx, metricSenders, cfg.MetricInterval)

	// Wait for shutdown signal (context cancellation)
	<-ctx.Done()
	log.Println("Shutdown complete")

	// Close all clients
	for _, s := range logSenders {
		s.client.Close()
	}

	for _, s := range metricSenders {
		s.client.Close()
	}

}